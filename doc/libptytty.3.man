.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "libptytty 3"
.TH libptytty 3 "2006-01-23" "" "LIBPTYTTY"
.SH "NAME"
libptytty \- OS independent and secure pty/tty and utmp/wtmp/lastlog handling
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   -lptytty
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1TODO\s0
.SH "SECURITY CONSIDERATIONS"
.IX Header "SECURITY CONSIDERATIONS"
\&\fI\f(BIIt is of paramount importance that you at least read the following
paragraph!\fI\fR
.PP
If you are a typical terminal-like program that just wants one or more
ptys, you should call the \f(CW\*(C`ptytty::init ()\*(C'\fR method (C: \f(CW\*(C`ptytty_init ()\*(C'\fR
function) as the very first thing in your program:
.PP
.Vb 5
\&   int main (int argc, char *argv[])
\&   {
\&      // do nothing here
\&      ptytty::init ();
\&      // in C: ptytty_init ();
.Ve
.PP
.Vb 2
\&      // initialise, parse arguments, etc.
\&   }
.Ve
.PP
This checks wether the program runs setuid or setgid. If yes then it will
fork a helper process and drop privileges.
.PP
Some programs need finer control over if and when this helper process
is started, and if and how to drop privileges. For those programs, the
methods \f(CW\*(C`ptytty::use_helper\*(C'\fR and \f(CW\*(C`ptytty::drop_privileges\*(C'\fR are more
useful.
.SH "\*(C+ INTERFACE: THE ptytty CLASS"
.IX Header " INTERFACE: THE ptytty CLASS"
.Sh "\s-1STATIC\s0 \s-1METHODS\s0"
.IX Subsection "STATIC METHODS"
.IP "ptytty::init ()" 4
.IX Item "ptytty::init ()"
The default way to initialise libptytty. Must be called imemdiately as
the first thing in the \f(CW\*(C`main\*(C'\fR function, or earlier e.g. during static
construction time. The earlier, the better.
.Sp
This method checks wether the program runs with setuid/setgid permissions
and, if yes, spawns a helper process for pty/tty management. \s-1IT\s0 then
drops the privileges completely, so the actual program runs without
setuid/setgid privileges.
.IP "ptytty::use_helper ()" 4
.IX Item "ptytty::use_helper ()"
Tries to start a helper process that retains privileges even when the
calling process does not. This is usually called from \f(CW\*(C`ptytty::init\*(C'\fR when
it detects that the program is running setuid or setgid, but can be called
manually if it is inconvinient to drop privileges at startup, or when
you are not running setuid/setgid but want to drop privileges (e.g. when
running as a root-started daemon).
.Sp
This method will try not to start more than one helper process. The same
helper process cna usually be used form the process starting it an all its
fork'ed (not exec'ed) children
.IP "ptytty::drop_privileges ()" 4
.IX Item "ptytty::drop_privileges ()"
Drops privileges completely, i.e. sets real, effective and saved user id
to the real user id. Also aborts if this cnanot be achieved. Useful to
make sure that the process doesn't run with special privileges.
.IP "bool success = ptytty::send_fd (int socket, int fd)" 4
.IX Item "bool success = ptytty::send_fd (int socket, int fd)"
Utility method to send a file descriptor over a unix domain
socket. Returns true if successful, false otherwise. This method is only
exposed for your convinience and is not required for normal operation.
.IP "int fd = ptytty::recv_fd (int socket)" 4
.IX Item "int fd = ptytty::recv_fd (int socket)"
Utility method to receive a file descriptor over a unix domain
socket. Returns the fd if sucecssful and \f(CW\*(C`\-1\*(C'\fR otherwise. This method
is only exposed for your convinience and is not required for normal
operation.
.IP "ptytty *pty = ptytty::create ()" 4
.IX Item "ptytty *pty = ptytty::create ()"
Creates new ptytty object. Creation does not yet do anything besides
allocating the structure.
.Sp
A static method is used because the actual ptytty implementation can
differ at runtime, so you need a dynamic object creation facility.
.Sh "\s-1DYNAMIC/SESSION\-RELATED\s0 \s-1DATA\s0 \s-1MEMBERS\s0 \s-1AND\s0 \s-1METHODS\s0"
.IX Subsection "DYNAMIC/SESSION-RELATED DATA MEMBERS AND METHODS"
.IP "int pty_fd = pty\->pty" 4
.IX Item "int pty_fd = pty->pty"
.PD 0
.IP "int tty_fd = pty\->tty" 4
.IX Item "int tty_fd = pty->tty"
.PD
These members contain the pty and tty file descriptors, respectively. They
initially contain \f(CW\*(C`\-1\*(C'\fR until a successful to \f(CW\*(C`ptytty::get\*(C'\fR.
.IP "bool success = pty\->get ()" 4
.IX Item "bool success = pty->get ()"
Tries to find, allocate and initialise a new pty/tty pair. Returns \f(CW\*(C`true\*(C'\fR
when successful.
.IP "pty\->login (int cmd_pid, bool login_shell, const char *hostname)" 4
.IX Item "pty->login (int cmd_pid, bool login_shell, const char *hostname)"
Creates an entry in the systems session database(s) (utmp, wtmp, lastlog).
\&\f(CW\*(C`cmd_pid\*(C'\fR must be the pid of the process representing the session
(such as the login shell), \f(CW\*(C`login_shell\*(C'\fR defines wether the session is
associated with a login, which influences wether wtmp and lastlog entries
are created, and \f(CW\*(C`hostname\*(C'\fR should identify the \*(L"hostname\*(R" the user logs
in from, which often is the value of the \f(CW\*(C`DISPLAY\*(C'\fR variable or tty line
in case of local logins.
.Sp
Calling this method is optional. A session starts at the time of the login
call and extends until the ptytty object is destroyed.
.IP "pty\->close_tty ()" 4
.IX Item "pty->close_tty ()"
Closes the tty. Useful after forking in the parent/pty process.
.IP "bool success = pty\->make_controlling_tty ()" 4
.IX Item "bool success = pty->make_controlling_tty ()"
Tries to make the pty/tty pair the controlling terminal of the current
process. Useful after forking in the child/tty process.
.IP "pty\->set_utf8_mode (bool on)" 4
.IX Item "pty->set_utf8_mode (bool on)"
On systems supporting special \s-1UTF\-8\s0 line disciplines (e.g. Linux), tries
to enable it for the given pty. Can be called at any time to change the
mode.
.SH "C INTERFACE: THE ptytty FAMILY OF FUNCTIONS"
.IX Header "C INTERFACE: THE ptytty FAMILY OF FUNCTIONS"
.IP "ptytty_init ()" 4
.IX Item "ptytty_init ()"
See \f(CW\*(C`ptytty::init ()\*(C'\fR.
.IP "\s-1PTYTTY\s0 ptytty_create ()" 4
.IX Item "PTYTTY ptytty_create ()"
Creates a new opaque \s-1PTYTTY\s0 object and returns it. Do not try to access it
in any way excecp by testing it for truthness (e.g. \f(CW\*(C`if (pty) ....\*(C'\fR). See
\&\f(CW\*(C`ptytty::create ()\*(C'\fR.
.IP "int ptytty_pty (\s-1PTYTTY\s0 ptytty)" 4
.IX Item "int ptytty_pty (PTYTTY ptytty)"
Return the pty file descriptor. See \f(CW\*(C`pty\->pty\*(C'\fR.
.IP "int ptytty_tty (\s-1PTYTTY\s0 ptytty)" 4
.IX Item "int ptytty_tty (PTYTTY ptytty)"
Return the tty file descriptor. See \f(CW\*(C`pty\->tty\*(C'\fR.
.IP "void ptytty_delete (\s-1PTYTTY\s0 ptytty)" 4
.IX Item "void ptytty_delete (PTYTTY ptytty)"
Destroys the \s-1PTYTTY\s0 object, freeing the pty/tty pair and cleaning up the
utmp/wtmp/lastlog databases, if initialised/used. Same as \f(CW\*(C`delete pty\*(C'\fR in
\&\*(C+.
.IP "int ptytty_get (\s-1PTYTTY\s0 ptytty)" 4
.IX Item "int ptytty_get (PTYTTY ptytty)"
See \f(CW\*(C`pty\->get\*(C'\fR, returns 0 in case of an error, non-zero otherwise.
.IP "void ptytty_login (\s-1PTYTTY\s0 ptytty, int cmd_pid, bool login_shell, const char *hostname)" 4
.IX Item "void ptytty_login (PTYTTY ptytty, int cmd_pid, bool login_shell, const char *hostname)"
See \f(CW\*(C`pty\->login\*(C'\fR.
.IP "void ptytty_close_tty (\s-1PTYTTY\s0 ptytty)" 4
.IX Item "void ptytty_close_tty (PTYTTY ptytty)"
See \f(CW\*(C`pty\->close_tty\*(C'\fR.
.IP "int ptytty_make_controlling_tty (\s-1PTYTTY\s0 ptytty)" 4
.IX Item "int ptytty_make_controlling_tty (PTYTTY ptytty)"
See \f(CW\*(C`pty\->make_controlling_tty\*(C'\fR.
.IP "void ptytty_set_utf8_mode (\s-1PTYTTY\s0 ptytty, int on)" 4
.IX Item "void ptytty_set_utf8_mode (PTYTTY ptytty, int on)"
See \f(CW\*(C`pty\->set_utf8_mode\*(C'\fR.
.IP "void ptytty_drop_privileges ()" 4
.IX Item "void ptytty_drop_privileges ()"
See \f(CW\*(C`ptytty::drop_privileges\*(C'\fR.
.IP "void ptytty_use_helper ()" 4
.IX Item "void ptytty_use_helper ()"
See \f(CW\*(C`ptytty::use_helper\*(C'\fR.
.SH "BUGS"
.IX Header "BUGS"
You kiddin'?
.SH "AUTHORS"
.IX Header "AUTHORS"
Emanuele Giaquinta <e.giaquinta@glauco.it>, Marc Alexander Lehmann
<rxvt\-unicode@schmorp.de>.
