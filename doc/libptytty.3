.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "libptytty 3"
.TH libptytty 3 "2021-07-27" "2.0" "LIBPTYTTY"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
libptytty \- OS independent and secure pty/tty and utmp/wtmp/lastlog handling
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   cc ... \-lptytty
\&
\&   #include <libptytty.h>
\&
\&
\&   // C++
\&   ptytty *pty = ptytty::create ();
\&
\&   if (!pty\->get ())
\&     // error allocating pty
\&
\&   if (we want utmp)
\&     pty\->login (process_pid, 0, "remote.host");
\&   else if (we want utmp AND wtmp/lastlog)
\&     pty\->login (process_pid, 1, "remote.host");
\&
\&   // we are done with it
\&   delete pty;
\&
\&
\&   // C
\&   PTYTTY pty = ptytty_create ();
\&
\&   if (!ptytty_get (pty))
\&     // error allocating pty
\&
\&   if (we want utmp)
\&     ptytty_login (pty, process_pid, 0, "remote.host");
\&   else if (we want utmp AND wtmp/lastlog)
\&     ptytty_login (pty, process_pid, 1, "remote.host");
\&
\&   // we are done with it
\&   ptytty_delete (pty);
.Ve
.PP
See also the \fIeg/\fR directory, which currently contains the \fIc\-sample.c\fR
file that spawns a login shell from C using libptytty.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Libptytty is a small library that offers pseudo-tty management in an
OS-independent way.  It was created out of frustration over the many
differences of pty/tty handling in different operating systems for the use
inside \f(CW\*(C`rxvt\-unicode\*(C'\fR.
.PP
In addition to offering mere pty/tty management, it also offers session
database support (utmp and optional wtmp/lastlog updates for login
shells).
.PP
It also supports fork'ing after startup and dropping privileges in the
calling process, so in case the calling process gets compromised by the
user starting the program there is less to gain, as only the helper
process runs with privileges (e.g. setuid/setgid), which reduces the area
of attack immensely.
.PP
Libptytty is written in \*(C+, but it also offers a C\-only \s-1API.\s0
.SH "INSTALLATION"
.IX Header "INSTALLATION"
libptytty uses \f(CW\*(C`CMake\*(C'\fR as build system. To build libptytty, install
\&\f(CW\*(C`CMake\*(C'\fR and run the following commands from either the libptytty
source directory or a separate build directory:
.PP
.Vb 3
\&   cmake \-DCMAKE_INSTALL_PREFIX=<prefix> \-DBUILD_SHARED_LIBS=ON <path/to/libptytty>
\&   cmake \-\-build .
\&   cmake \-\-install .
.Ve
.SH "SECURITY CONSIDERATIONS"
.IX Header "SECURITY CONSIDERATIONS"
\&\fI\f(BIIt is of paramount importance that you at least read the following
paragraph!\fI\fR
.PP
If you write a typical terminal-like program that just wants one or more
ptys, you should call the \f(CW\*(C`ptytty::init ()\*(C'\fR method (C: \f(CW\*(C`ptytty_init ()\*(C'\fR
function) as the very first thing in your program:
.PP
.Vb 5
\&   int main (int argc, char *argv[])
\&   {
\&      // do nothing here
\&      ptytty::init ();
\&      // in C: ptytty_init ();
\&
\&      // initialise, parse arguments, etc.
\&   }
.Ve
.PP
This checks whether the program runs setuid or setgid. If yes then it will
fork a helper process and drop privileges.
.PP
Some programs need finer control over if and when this helper process
is started, and if and how to drop privileges. For those programs, the
methods \f(CW\*(C`ptytty::use_helper\*(C'\fR and \f(CW\*(C`ptytty::drop_privileges\*(C'\fR (and possibly
\&\f(CW\*(C`ptytty::sanitise_stdfd\*(C'\fR) are more useful.
.SH "\*(C+ INTERFACE: THE ptytty CLASS"
.IX Header " INTERFACE: THE ptytty CLASS"
.SS "\s-1STATIC METHODS\s0"
.IX Subsection "STATIC METHODS"
.IP "ptytty::init ()" 4
.IX Item "ptytty::init ()"
The default way to initialise libptytty. Must be called immediately as
the first thing in the \f(CW\*(C`main\*(C'\fR function, or earlier e.g. during static
construction time. The earlier, the better.
.Sp
This method calls \f(CW\*(C`sanitise_stdfd\*(C'\fR and then checks whether the program runs
with setuid/setgid permissions and, if yes, spawns a helper process for
pty/tty management. It then drops the privileges completely, so the actual
program runs without setuid/setgid privileges.
.Sp
On failure, this method throws a \f(CW\*(C`ptytty_error\*(C'\fR exception.
.IP "ptytty::use_helper ()" 4
.IX Item "ptytty::use_helper ()"
Tries to start a helper process that retains privileges even when the
calling process does not. This is usually called from \f(CW\*(C`ptytty::init\*(C'\fR when
it detects that the program is running setuid or setgid, but can be called
manually if it is inconvenient to drop privileges at startup, or when
you are not running setuid/setgid but want to drop privileges (e.g. when
running as a root-started daemon).
.Sp
This method will try not to start more than one helper process. The same
helper process can usually be used both from the process starting it and
all its fork'ed (not exec'ed) children.
.Sp
On failure, this method throws a \f(CW\*(C`ptytty_error\*(C'\fR exception.
.IP "ptytty::drop_privileges ()" 4
.IX Item "ptytty::drop_privileges ()"
Drops privileges completely, i.e. sets real, effective and saved user
id to the real user id. Useful to make sure that the process doesn't
run with special privileges.
.Sp
On failure, this method throws a \f(CW\*(C`ptytty_error\*(C'\fR exception.
.IP "ptytty::sanitise_stdfd ()" 4
.IX Item "ptytty::sanitise_stdfd ()"
Checks whether file descriptors 0, 1 and 2 (stdin, stdout and stderr)
are valid (open) and, if not, connects them to \fI/dev/tty\fR or
\&\fI/dev/null\fR if possible. This is necessary because libptytty might
want to output error messages to those descriptors, which at the time
of outputting the error message, might be connected to something
unsuitable opened by the unsuspecting program itself (this can be a
security issue).
.Sp
On failure, this method throws a \f(CW\*(C`ptytty_error\*(C'\fR exception.
.IP "bool success = ptytty::send_fd (int socket, int fd)" 4
.IX Item "bool success = ptytty::send_fd (int socket, int fd)"
Utility method to send a file descriptor over a unix domain
socket. Returns true if successful, false otherwise. This method is only
exposed for your convenience and is not required for normal operation.
.IP "int fd = ptytty::recv_fd (int socket)" 4
.IX Item "int fd = ptytty::recv_fd (int socket)"
Utility method to receive a file descriptor over a unix domain
socket. Returns the fd if successful and \f(CW\*(C`\-1\*(C'\fR otherwise. This method
is only exposed for your convenience and is not required for normal
operation.
.IP "ptytty *pty = ptytty::create ()" 4
.IX Item "ptytty *pty = ptytty::create ()"
Creates new ptytty object. Creation does not yet do anything besides
allocating the structure.
.Sp
A static method is used because the actual ptytty implementation can
differ at runtime, so you need a dynamic object creation facility.
.SS "\s-1DYNAMIC/SESSION\-RELATED DATA MEMBERS AND METHODS\s0"
.IX Subsection "DYNAMIC/SESSION-RELATED DATA MEMBERS AND METHODS"
.IP "int pty_fd = pty\->pty" 4
.IX Item "int pty_fd = pty->pty"
.PD 0
.IP "int tty_fd = pty\->tty" 4
.IX Item "int tty_fd = pty->tty"
.PD
These members contain the pty and tty file descriptors, respectively. They
initially contain \f(CW\*(C`\-1\*(C'\fR until a successful call to \f(CW\*(C`ptytty::get\*(C'\fR.
.IP "bool success = pty\->get ()" 4
.IX Item "bool success = pty->get ()"
Tries to find, allocate and initialise a new pty/tty pair. Returns \f(CW\*(C`true\*(C'\fR
when successful.
.Sp
If the helper process is running and there is a protocol error, this
method throws a \f(CW\*(C`ptytty_error\*(C'\fR exception.
.IP "pty\->login (int cmd_pid, bool login_shell, const char *hostname)" 4
.IX Item "pty->login (int cmd_pid, bool login_shell, const char *hostname)"
Creates an entry in the systems session database(s) (utmp, wtmp, lastlog).
\&\f(CW\*(C`cmd_pid\*(C'\fR must be the pid of the process representing the session
(such as the login shell), \f(CW\*(C`login_shell\*(C'\fR defines whether the session is
associated with a login, which influences whether wtmp and lastlog entries
are created, and \f(CW\*(C`hostname\*(C'\fR should identify the \*(L"hostname\*(R" the user logs
in from, which often is the value of the \f(CW\*(C`DISPLAY\*(C'\fR variable or tty line
in case of local logins.
.Sp
Calling this method is optional. A session starts at the time of the login
call and extends until the ptytty object is destroyed.
.IP "pty\->close_tty ()" 4
.IX Item "pty->close_tty ()"
Closes the tty. Useful after forking in the parent/pty process.
.IP "bool success = pty\->make_controlling_tty ()" 4
.IX Item "bool success = pty->make_controlling_tty ()"
Tries to make the pty/tty pair the controlling terminal of the current
process. Useful after forking in the child/tty process.
.IP "pty\->set_utf8_mode (bool on)" 4
.IX Item "pty->set_utf8_mode (bool on)"
On systems supporting special \s-1UTF\-8\s0 line disciplines (e.g. Linux), this
tries to enable this discipline for the given pty. Can be called at any
time to change the mode.
.SH "C INTERFACE: THE ptytty FAMILY OF FUNCTIONS"
.IX Header "C INTERFACE: THE ptytty FAMILY OF FUNCTIONS"
.IP "ptytty_init ()" 4
.IX Item "ptytty_init ()"
See \f(CW\*(C`ptytty::init ()\*(C'\fR.
.IP "\s-1PTYTTY\s0 ptytty_create ()" 4
.IX Item "PTYTTY ptytty_create ()"
Creates a new opaque \s-1PTYTTY\s0 object and returns it. Do not try to access it
in any way except by testing it for truthness (e.g. \f(CW\*(C`if (pty) ....\*(C'\fR). See
\&\f(CW\*(C`ptytty::create ()\*(C'\fR.
.IP "int ptytty_pty (\s-1PTYTTY\s0 ptytty)" 4
.IX Item "int ptytty_pty (PTYTTY ptytty)"
Return the pty file descriptor. See \f(CW\*(C`pty\->pty\*(C'\fR.
.IP "int ptytty_tty (\s-1PTYTTY\s0 ptytty)" 4
.IX Item "int ptytty_tty (PTYTTY ptytty)"
Return the tty file descriptor. See \f(CW\*(C`pty\->tty\*(C'\fR.
.IP "void ptytty_delete (\s-1PTYTTY\s0 ptytty)" 4
.IX Item "void ptytty_delete (PTYTTY ptytty)"
Destroys the \s-1PTYTTY\s0 object, freeing the pty/tty pair and cleaning up the
utmp/wtmp/lastlog databases, if initialised/used. Same as \f(CW\*(C`delete pty\*(C'\fR in
\&\*(C+.
.IP "int ptytty_get (\s-1PTYTTY\s0 ptytty)" 4
.IX Item "int ptytty_get (PTYTTY ptytty)"
See \f(CW\*(C`pty\->get\*(C'\fR, returns 0 in case of an error, non-zero otherwise.
.IP "void ptytty_login (\s-1PTYTTY\s0 ptytty, int cmd_pid, bool login_shell, const char *hostname)" 4
.IX Item "void ptytty_login (PTYTTY ptytty, int cmd_pid, bool login_shell, const char *hostname)"
See \f(CW\*(C`pty\->login\*(C'\fR.
.IP "void ptytty_close_tty (\s-1PTYTTY\s0 ptytty)" 4
.IX Item "void ptytty_close_tty (PTYTTY ptytty)"
See \f(CW\*(C`pty\->close_tty\*(C'\fR.
.IP "int ptytty_make_controlling_tty (\s-1PTYTTY\s0 ptytty)" 4
.IX Item "int ptytty_make_controlling_tty (PTYTTY ptytty)"
See \f(CW\*(C`pty\->make_controlling_tty\*(C'\fR.
.IP "void ptytty_set_utf8_mode (\s-1PTYTTY\s0 ptytty, int on)" 4
.IX Item "void ptytty_set_utf8_mode (PTYTTY ptytty, int on)"
See \f(CW\*(C`pty\->set_utf8_mode\*(C'\fR.
.IP "void ptytty_drop_privileges ()" 4
.IX Item "void ptytty_drop_privileges ()"
See \f(CW\*(C`ptytty::drop_privileges\*(C'\fR.
.IP "void ptytty_use_helper ()" 4
.IX Item "void ptytty_use_helper ()"
See \f(CW\*(C`ptytty::use_helper\*(C'\fR.
.SH "PORTABILITY"
.IX Header "PORTABILITY"
To date, libptytty has been tested on the following platforms:
.IP "GNU/Linux" 4
.IX Item "GNU/Linux"
.PD 0
.IP "FreeBSD" 4
.IX Item "FreeBSD"
.IP "NetBSD" 4
.IX Item "NetBSD"
.IP "OpenBSD" 4
.IX Item "OpenBSD"
.IP "macOS" 4
.IX Item "macOS"
.IP "Solaris" 4
.IX Item "Solaris"
.IP "\s-1AIX\s0" 4
.IX Item "AIX"
.PD
.SH "BUGS"
.IX Header "BUGS"
You kiddin'?
.SH "AUTHORS"
.IX Header "AUTHORS"
Emanuele Giaquinta <emanuele.giaquinta@gmail.com>, Marc Alexander Lehmann
<rxvt\-unicode@schmorp.de>.
